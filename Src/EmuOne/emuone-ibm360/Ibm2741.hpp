//
//  emuone-ibm360/Ibm2741.hpp
//
//  IBM 2741 terminal
//
//////////
#pragma once

namespace ibm360
{
    //////////
    //  The IBM 2741 terminal
    class EMUONE_IBM360_EXPORT Ibm2741 : public Device
    {
        CANNOT_ASSIGN_OR_COPY_CONSTRUCT(Ibm2741)

        friend class Ibm2741Editor;
        friend class Ibm2741FullScreenWidget;

        //////////
        //  Types
    public:
        //  The "type" of IBM 2741 terminal
        class EMUONE_IBM360_EXPORT Type : public core::ComponentType
        {
            DECLARE_SINGLETON(Type)

            //////////
            //  StockObject
        public:
            virtual QString     mnemonic() const override;
            virtual QString     displayName() const override;

            //////////
            //  ComponentType
        public:
            virtual core::ComponentCategory *   category() const override;
            virtual bool        isCompatibleWith(core::Architecture * architecture) const override;
            virtual Ibm2741 *   createComponent() override;
        };

        //  The "UI" of IBM 2741 terminal
        class EMUONE_IBM360_EXPORT Ui : public core::ComponentUi
        {
            CANNOT_ASSIGN_OR_COPY_CONSTRUCT(Ui)

            //////////
            //  Construction/destruction
        public:
            explicit Ui(Ibm2741 * ibm2741);
            virtual ~Ui();

            //////////
            //  core::ComponentUi
        public:
            virtual core::FullScreenWidgetList  fullScreenWidgets() override;

            //////////
            //  Implementation
        private:
            Ibm2741FullScreenWidget *   _fullScreenWidget;
        };

        //  Errors that can be generated by IBM 2741
        enum class ErrorCode
        {
            Success,
            Busy,           //  I/O could not be started because the device is busy
            Interrupted,    //  I/O operation has stopped half-way by "haltIo()"
            Unknown
        };

        //  The listener to completion of I/O requests that do not involve data transfer
        class EMUONE_IBM360_EXPORT IoCompletionListener
        {
            //////////
            //  This is an interface
        public:
            virtual ~IoCompletionListener() {}

            //////////
            //  Operations
        public:
            virtual void        ioCompleted(ErrorCode errorCode) = 0;
        };

        //  The listener to completion of I/O requests that involve data transfer
        class EMUONE_IBM360_EXPORT TransferCompletionListener
        {
            //////////
            //  This is an interface
        public:
            virtual ~TransferCompletionListener() {}

            //////////
            //  Operations
        public:
            virtual void        transferCompleted(uint32_t bytesTransferred, ErrorCode errorCode) = 0;
        };

        //  The current "operational state" of the device
        enum class DeviceState
        {
            Resetting,
            Idle,
            Reading,
            Writing,
            NotOperational
        };

        //////////
        //  Construction/destruction
    public:
        Ibm2741(const QString & name, uint16_t address);
        virtual ~Ibm2741();

        //////////
        //  Component
    public:
        virtual core::ComponentType*type() const override;
        virtual ComponentEditor *   createEditor(QWidget * parent) override;
        virtual QString             shortStatus() const override;
        virtual core::ComponentUi * createUi() override;

        //////////
        //  Component (state control) - all thread-safe
    public:
        virtual State           state() const override;
        virtual void            connect() override;
        virtual void            initialise() override;
        virtual void            start() override;
        virtual void            stop() noexcept override;
        virtual void            deinitialise() noexcept override;
        virtual void            disconnect() noexcept override;

        //////////
        //  Component (serialisation)
    public:
        virtual void            serialiseConfiguration(QDomElement & configurationElement) const override;
        virtual void            deserialiseConfiguration(QDomElement & configurationElement) override;

        //////////
        //  Operations
    public:
        //  The current "operational state" of this device
        DeviceState             deviceState() const { return _deviceState; }

        //  Initiates a "reset" operation.
        //  If a "reset" begins successfully, the method returns "Success" and the
        //  "completionListener" is guaranteed to eventually be notified when the
        //  "reset" is done. This is done on an internal worker thread.
        //  If the "reset" cannot be started, returns the non-"Success" error code.
        ErrorCode               beginReset(IoCompletionListener * completionListener);

        //  Initiates a "write" operation.
        //  If a "write" begins successfully, the method returns "Success" and the
        //  "completionListener" is guaranteed to eventually be notified when the
        //  "write" is done. This is done on an internal worker thread.
        //  If the "write" cannot be started, returns the non-"Success" error code.
        ErrorCode               beginWrite(const util::Buffer * buffer, TransferCompletionListener * completionListener);

        //  Same as "beginWrite()", but goes to new line after writing
        ErrorCode               beginWriteBlock(const util::Buffer * buffer, TransferCompletionListener * completionListener);

        //  Initiates a "read" operation in stream mode.
        //  If a "read" begins successfully, the method returns "Success" and the
        //  "completionListener" is guaranteed to eventually be notified when the
        //  "read" is done. This is done on an internal worker thread.
        //  If the "read" cannot be started, returns the non-"Success" error code.
        //  At most "buffer.size()" bytes are read.
        ErrorCode               beginRead(util::Buffer * buffer, TransferCompletionListener * completionListener);

        //  Initiates a "read" operation in block mode.
        //  Exactly 1 line of input is read; the '\n' is not added to the line's end.
        ErrorCode               beginReadBlock(util::Buffer * buffer, TransferCompletionListener * completionListener);

        //  Instructs this device to halt any I/O-in-progress ASAP.
        //  If there was, the corresponding "completionListener" is notified that the
        //  I/O was finished by interruption; otherwise has no effect.
        ErrorCode               haltIo();

        //////////
        //  Implementation
    private:
        State                   _state = State::Constructed;
        mutable QRecursiveMutex _stateGuard;

        Ibm2741EditorList       _editors;   //  ...that have been created so far

        //  Runtime state
        volatile DeviceState    _deviceState = DeviceState::NotOperational;

        class _Cell
        {   //  A position where a single character can be printed or
            //  several characters can be over-printed
        public:
            _Cell(QChar ch) { chars.append(ch); }

            QList<QChar>      chars;
        };

        class _Line
        {   //  A single printed line
        public:
            QList<_Cell>        _cells; //  0 <= length <= 80
        };

        class _Content
        {   //  The entire content printed so far
        public:
            QList<_Line>        _lines;
        };

        _Content                _content;       //  ASCII
        int                     _cursorY;       //  0 <= _cursorY < _content._lines.size()
        int                     _cursorX;       //  0 <= _cursorX <= 80
        QString                 _pendingInput;  //  ASCII

        util::BlockingQueue<QChar>  _charsToEcho;

        //  Helpers
        void            _printChar(QChar ch);
        void            _newLine();

        //////////
        //  Requests sent to the worker thread
        class _Request
        {
            CANNOT_ASSIGN_OR_COPY_CONSTRUCT(_Request)

            //////////
            //  Construction/destruction
        public:
            _Request() {}
            virtual ~_Request() {}
        };

        class _ResetRequest : public _Request
        {
            CANNOT_ASSIGN_OR_COPY_CONSTRUCT(_ResetRequest)

            //////////
            //  Construction/destruction
        public:
            explicit _ResetRequest(IoCompletionListener * completionListener)
                :   completionListener(completionListener) {}
            virtual ~_ResetRequest() {}

            //////////
            //  Properties
        public:
            IoCompletionListener *const completionListener;
        };

        class _WriteRequest : public _Request
        {
            CANNOT_ASSIGN_OR_COPY_CONSTRUCT(_WriteRequest)

            //////////
            //  Construction/destruction
        public:
            _WriteRequest(const util::Buffer * buffer, TransferCompletionListener * completionListener)
                :   buffer(buffer), completionListener(completionListener) {}
            virtual ~_WriteRequest() {}

            //////////
            //  Properties
        public:
            const util::Buffer *const           buffer;
            TransferCompletionListener *const   completionListener;
        };

        class _WriteBlockRequest : public _Request
        {
            CANNOT_ASSIGN_OR_COPY_CONSTRUCT(_WriteBlockRequest)

            //////////
            //  Construction/destruction
        public:
            _WriteBlockRequest(const util::Buffer * buffer, TransferCompletionListener * completionListener)
                :   buffer(buffer), completionListener(completionListener) {}
            virtual ~_WriteBlockRequest() {}

            //////////
            //  Properties
        public:
            const util::Buffer *const           buffer;
            TransferCompletionListener *const   completionListener;
        };

        class _ReadRequest : public _Request
        {
            CANNOT_ASSIGN_OR_COPY_CONSTRUCT(_ReadRequest)

            //////////
            //  Construction/destruction
        public:
            _ReadRequest(util::Buffer * buffer, TransferCompletionListener * completionListener)
                :   buffer(buffer), completionListener(completionListener) {}
            virtual ~_ReadRequest() {}

            //////////
            //  Properties
        public:
            util::Buffer *const                 buffer;
            TransferCompletionListener *const   completionListener;
        };

        class _ReadBlockRequest : public _Request
        {
            CANNOT_ASSIGN_OR_COPY_CONSTRUCT(_ReadBlockRequest)

            //////////
            //  Construction/destruction
        public:
            _ReadBlockRequest(util::Buffer * buffer, TransferCompletionListener * completionListener)
                :   buffer(buffer), completionListener(completionListener) {}
            virtual ~_ReadBlockRequest() {}

            //////////
            //  Properties
        public:
            util::Buffer *const                 buffer;
            TransferCompletionListener *const   completionListener;
        };

        class _EchoCompletionListener : public TransferCompletionListener
        {
            CANNOT_ASSIGN_OR_COPY_CONSTRUCT(_EchoCompletionListener)

            //////////
            //  Construction/destruction
        public:
            explicit _EchoCompletionListener(Ibm2741 * ibm2741) : _ibm2741(ibm2741) {}
            virtual ~_EchoCompletionListener() {}

            //////////
            //  TransferCompletionListener
        public:
            virtual void        transferCompleted(uint32_t /*bytesTransferred*/, ErrorCode /*errorCode*/) override {}

            //////////
            //  Implementation
        private:
            Ibm2741 *const      _ibm2741;
        };
        _EchoCompletionListener _echoCompletionListener;

        //////////
        //  Threads
        util::BlockingQueue<_Request*>  _requestQueue;

        class _WorkerThread : public QThread
        {
            CANNOT_ASSIGN_OR_COPY_CONSTRUCT(_WorkerThread)

            friend class Ibm2741FullScreenWidget;

            //////////
            //  Construction/destruction
        public:
            explicit _WorkerThread(Ibm2741 * ibm2741);
            virtual ~_WorkerThread();

            //////////
            //  QThread
        public:
            virtual void    run() override;

            //////////
            //  Operations
        public:
            void            requestStop() { _stopRequested = true;  }
            void            requestHaltIo() { _haltIoRequested = true;  }

            //////////
            //  Implementation
        private:
            Ibm2741 *const  _ibm2741;
            volatile bool   _stopRequested = false;
            util::CharacterSet::Decoder * _ebcdicDecoder;
            QByteArray      _decodeBuffer;
            util::CharacterSet::Encoder * _ebcdicEncoder;
            QByteArray      _encodeBuffer;

            volatile bool   _haltIoRequested = false;

            //  Helpers
            void            _handleResetRequest(const _ResetRequest * request);
            void            _handleWriteRequest(const _WriteRequest * request);
            void            _handleWriteBlockRequest(const _WriteBlockRequest * request);
            void            _handleReadRequest(const _ReadRequest * request);
            void            _handleReadBlockRequest(const _ReadBlockRequest * request);
        };
        _WorkerThread *     _workerThread = nullptr;
    };
}

//  End of emuone-ibm360/Ibm2741.hpp
